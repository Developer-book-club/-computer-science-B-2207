## 3.3.1 프로세스와 컴파일 과정

### 프로그램과 프로세스 
- 프로그램 Program (애플리케이션, 앱)
   - 하드디스크에 저장된 수동적인 파일로, 컴파일 과정을 거쳐 실행 가능
    - OS가 보조기억장치에서 프로그램을 주기억장치에 로드, 필요한 자원을 할당해 프로세스가 됨
- 프로세스 Process
    - 프로그램이 메모리에 올라가 실행되고 있는 것
    - 메모리, CPU, 입출력 장치를 모두 사용하기에 능동적
    - CPU 스케쥴링의 대상이 되는 작업 task와 거의 동일한 의미

### 프로세스의 생성 과정
- OS가 부팅되고 0번 프로세스가 실행될 때 한번 생성
  1. ‘프로그램’ (.exe) 실행
  2. OS가 해당 프로그램의 코드 영역과 데이터 영역을 메모리에 로드하고 빈 스택과 빈 힙을 만들어 공간을 확보
  3. 신규 프로세스를 관리하기 위한 PCB를 생성해 값을 초기화
- 이후 생성되는 프로세스는 0번 프로세스의 코드 영역, 데이터 영역, 스택 영역, PCB를 전부 복사 (`fork()`)
- 이후 `exec()` 함수를 실행, 복사한 영역을 원하는 값으로 덮어씀
- 0번 프로세스와 다른 프로세스는 부모 프로세스와 자식 프로세스의 관계
- 자식보다 부모가 먼저 종료되면 자식은 좀비 프로세스가 됨
```c
#include <stdio.h>
#include <unisted.h>

int main () {
	int pid;
	pid = fork(); // 1: 부모 프로세스, 0: 자식 프로세스
	if (pid == 0) {
		execlp("InternetBrowser", "0", NULL);
		exit(0); // 자식 프로세스가 부모 프로세스에게 정상 종료를 알림 (Exit Status)
	} else {
		wait(NULL);
		printf("인터넷 브라우저 닫힘");
		exit(0);
	}
}
```

### 스레드 Thread
- 스레드 이전
  - OS가 실행하는 작업이 많을 수록 프로세스 수가 증가하고, 메모리에 코드/데이터/스택/힙 영역을 생성해야 함
- 스레드
  - 프로세스 내 작업의 흐름으로 복수 개가 있을 수 있고 OS가 구분할 수 있음 (작업 단위로 작동 가능)
  - 동일 프로세스 내 PCB/코드/데이터/힙 영역을 공유하고, 스택 영역은 별개로 가지고 있음
  - 낮은 안정성 (문제 발생 시 서로 영향을 미침)
  - 자원 효율성: 스택을 제외하고 모두 공유하기에 프로세스 사이 IPC 통신을 할 필요 없어 오버헤드가 적음 

### 컴파일 과정

- 소스 코드를 컴퓨터가 이해할 수 있는 기계어로 번역, 실행 가능한 파일 (프로세스)으로 만드는 과정
    
    ![https://miro.medium.com/max/1036/1*rJQ1RYtW9RWLOsikvz0wLA.png](https://miro.medium.com/max/1036/1*rJQ1RYtW9RWLOsikvz0wLA.png)
    
- 전처리 Pro-processing 과정 (C언어 기준)
    - 전처리기 Preprocessor 로 소스 코드 파일 (.c) 을 전처리된 소스 코드 파일 (.i) 로 변환
    - 소스 코드의 주석 제거, `#include`등 헤더 파일을 병합, `#define` 매크로를 치환
- 컴파일 Compilation 과정
    - 컴파일러 Compile 로 오류 처리, 코드 최적화 작업을 통해 고수준 C언어를 저수준 어셈블리어 (.s) 로 변환
    - 언어의 문법 검사와 동적 영역의 메모리 할당 (BSS, Data 영역)
- 어셈블리 Assembly 과정
    - 어셈블러 Assembler를 통해 어셈블리어 파일 (*.s)을 오브젝트 파일 (*.o, 즉 기계어)로 변환하는 과정
    - 오브젝트 파일: 사람이 알아볼 수 없는 기계어로 변환된 것,  확장자는 OS마다 다름
- 링킹 Linking 과정
    - 링커 Linker를 통해 오브젝트 파일과 프로그램 내 라이브러리 함수 등을 를 결합, 실행 파일을 만듬 (확장자 .exe, .out)
    - 정적 링킹 Static Linking
        - 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 과정
        - 낮은 외부 의존도, 낮은 메모리 효율 (중복 코드 등)
    - 동적 링킹 Dynamic Linking
        - 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하는 방식
        - 높은 외부 의존도, 높은 메모리 효율

### 컴파일 언어와 인터프리터 언어
- 컴파일 언어
  - 코드가 컴파일 과정을 거쳐 기계어로 실행파일을 만드는 언어
  - 속도가 빠름
  - C, C#, C++

	```c
	#include <stdio.h> // 전처리 과정에서 해당 파일 include
	#define MY_NUMBER 100 // 전처리 과정에서 MY_NUMBER 모두 100으로 치환

	int main (void) {
		int num1 = 50;
		printf("Result: %d", num1 + MY_NUMBER);

		getchar();
		return 0;
	}
	```
- 인터프리터 언어
  - 코드를 실행 시 한줄씩 해석해 실행하는 언어
  - 오류를 검사하지 않아 오류 발생 가능성도 있고 컴파일 언어에 비해 속도가 느림
  - Javascript, Python, Ruby