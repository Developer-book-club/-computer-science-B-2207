### 1.2.2 객체지향 프로그래밍 OOP, Object-Oriented
#### 개념
- 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식
- 설계에 많은 시간이 소요되며 처리 속도가 다른 프로그래밍 패러다임에 비해 느림
  
#### 장점
- 모듈화, 캡슐화로 인해 유지보수에 용이
- 객체지향적이기 때문에 현실 세계와 유사해 코드 이해가 쉽다
- 객체는 그 자체가 하나의 프로그램이기 때문에 다른 프로그램에서 재사용이 가능

#### 단점
- 처리 속도가 상대적으로 느리고 많은 양의 메모리를 사용하는 경향
- 설계 과정에 시간이 많이 소요

#### 예시
``` javascript
const ret = [1, 2, 3, 4, 5, 11, 23];
class List {
	constructor(list) {
		this.list = this;
		this.mx = list.reduce((max, num) => {
			return num > max ? num : max;
		}, 0)
	}
	getMax() {
		return this.max;
	}
}
const a = new List(ret);
console.log(a.getMax()); // 12
```

#### 특징
- `추상화 Abstraction`
  - 개념
    - 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것
  - 특징
    - Interface 단순화 : 너무 많은 기능을 노출하지 않음 (예기치 못한 사용중 변화를 줄일 수 있음)

- `캡슐화 Encapsulation`
  - 개념
    - 객체의 속성과 메서드를 하나의 단위로 묶고 일부를 외부에 감추어 은닉해 데이터 등을 보호
    - 직접 접근 대신 함수를 통해서만 접근 가능
  - 특징
    - 은닉화(hiding) : 구현을 숨기고, 동작만을 노출
    - 느슨한 결합(Loose Coupling) : 언제든 구현을 수정 가능
  
- `다형성 Polymorphism`
  - 개념
    - 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것, 오버로딩과 오버라이딩이 있음
  - 특징
    - Method 단순화 : 다형성이 없다면 상위 클래스에 종류별로 분기를 시켜서 Method를 하나하나 모두 다르게 만들어야 한다.

- `상속성 Inheritance`
  - 개념
    - 상위 개념의 특징을 하위 개념이 이어받아 재사용하거나 추가, 확장하는 것
    - 코드의 재사용 측명, 계층적 관계 생성, 유지 보수성 측면에서 이용
    

##### `오버로딩 Overloading` :
	같은 이름을 가진 메서드를 여러 개 두는 것
	컴파일 중에 발생하는 정적 다형성

##### `오버라이딩 Overriding` :
	주로 메서드 오버라이딩을 말함
	상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것
	런타임중에 발생하는 동적 다형성


### SOLID 설계 원칙
객체지향 프로그래밍 설계시 추상화를 위해 지켜야 하는 원칙

#### `단일 책임 원칙 SRP, Single Responsibility Principle`
- 모든 클래스는 각각 하나의 책임만 가져야 하는 원칙, 즉 모듈이 변경 되는 이유가 한 가지여야 한다는 것
- 해당 모듈이 오직 하나의 액터에 대해서만 책임, 변경이 필요할 때 수정 대상이 명확해짐

#### `개방-폐쇄 원칙 OCP, Open Closed Principle`
- 확장에 대해 열려있고 수정에 대해서는 닫혀있어야 한다는 원칙
  - 확장에 대해 열려 있다: 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장하기 용이
  - 수정에 대해 닫혀 있다: 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경가능

#### `리스코프 치환 원칙 LSP, Liskov Substitution Principle`
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 원칙
- 객체를 사용하는 클라이언트는 상위 타입이 하위 타입으로 변경되어도, 상위 타입의 퍼블릭 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다는 것
- 예를 들어, 두 클래스가 계층 관계에 있을 때 자식 객체를 부모 객체와 바꿀 수 있어야 함

#### `인터페이스 분리 원칙 ISP, Interface Segregation Principle`
- 하나의 일반적인 인터페이스 대신 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙
- 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 적절하게 분리
- 모든 클라이언트가 자신의 관심에 맞는 퍼블릭 인터페이스(외부에서 접근 가능한 메세지)만을 접근하여 불필요한 간섭을 최소화할 수 있으며, 기존 클라이언트에 영향을 주지 않은 채로 유연하게 객체의 기능을 확장하거나 수정가능

#### `의존 역전 원칙 DIP, Dependency Inversion Principle`
- 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 하는 원칙
- 상위 계층은 하위 계층의 구현에 의존해서는 안 되며, 하위 계층이 상위 계층에서 정의한 추상 타입에 의존해야 한다는 것


#### ref 
- https://st-lab.tistory.com/151
- https://mangkyu.tistory.com/194