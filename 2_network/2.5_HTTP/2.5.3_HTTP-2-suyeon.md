## HTTP/2

현재 널리 쓰이는 프로토콜.
HTTP 메시지를 바이너리 프레이밍 계층으로 바이너리 인코딩하여, 전송속도는 빨라지고 텍스트에 비해 전송 오류 발생 가능성이 훨씬 줄어들었다.

TLS 의 위에서 동작하므로 HTTPS 로 작성된 웹 사이트에만 적용이 가능하다.

### 헤더 압축

HTTP/1.x 가 헤더가 중복으로 인해 비효율적으로 크다는 문제를 가지고 있었는데, HTTP/2에서는 중복을 검출하고, 또 중복되지 않은 헤더에 대해서는 HPACK 압축 모듈을 이용해 압축한다.

#### HPACK 압축 형식

허프만 인코딩 압축 알고리즘 사용. 문자열을 문자 단위로 쪼개 빈도수를 세어, 빈도가 높은 정보는 적은 비트 수를 사용하여 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현해서 전체 데이터의 표현에 필요한 비트양을 줄이는 원리.(이진트리 내림차순 정렬)

### 멀티플렉싱

HTTP/1.x 에서 단일 TCP 커넥션에서 여러개의 패킷을 보낼 때 큐로 처리되어 병목(HOL Blocking)이 있었던 반면 HTTP/2 에서는 멀티플렉싱을 통해 패킷이 병렬로 전달되어 성능이 개선되었다.

서버와 클라이언트이 맺는 하나의 커넥션 안에 여러개의 독립적인 스트림이 만들어진다.<br/>
스트림은 메시지를 담고 있는데, '바이너리 프레임'이라는 바이너리 형식의 데이터 조각으로 쪼개져서 구성되어있다. 스트림은 서로 독립적이므로 하나의 스트림에 손실이 발생해도 다른 스트림은 정상적으로 도착한다.

각각의 스트림은 순서에 상관없이 목적지에 도착하고, 스트림 안에 있는 프레임은 프레임 헤더에 있는 스트림 넘버를 기반으로 재조합된다.(\*프레임 인터리빙)<br/>
그러나 만약 필요하다면 스트림에 우선순위를 부여할 수도 있고, 우선순위가 높은 메시지는 먼저 도착한다.

### 서버 푸시

클라이언트의 요청 없이 서버가 바로 리소스를 푸시할 수 있다. HTML에 포함된 CSS, js 리소스를 서버에서 클라이언트로 먼저 푸시해줄 수 있다.

서버에서 클라이언트가 필요로 할 것 같은 리소스를 미리 전쏭(PUSH_PROMISE frame)하고, 브라우저는 이를 임시 영역( temporary "quarantine" zone)에 가지고 있다가 리소스를 요청할 일이 있을 때 이 영역을 먼저 탐색한다.

웹 소켓도 서버 푸시를 할 수 있다.
7계층에서 시작하는 HTTP통신은 원칙적으로 stateless, 비연결적이지만 4계층에서 시작하는 소켓통신(HTTP도 하위 계층과는 소켓을 사이에 두고 교류하니까 엄밀히 말하면 소켓통신이지만 어쨌든 명칭이 나눠져있다)은 stateful, 연결지향적이다.

4계층 TCP 연결 및 종료에서는 handshake가 이루어지고 이 과정에서 클라이언트와 서버는 연결부터 직접 종료하기까지 서로의 상태를 인식하고 있다. 그래서 소켓통신이 연결지항적인 것.

---

#### 참고링크

[How HTTP/2 PUSH works at a protocol level](https://en.wikipedia.org/wiki/HTTP/2_Server_Push#How_HTTP/2_PUSH_works_at_a_protocol_level)
